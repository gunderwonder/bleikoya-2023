/*! @nrk/core-scroll v4.4.0 - Copyright (c) 2017-2022 NRK */
'use strict';

function _typeof(obj) {
  "@babel/helpers - typeof";

  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, _typeof(obj);
}

function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}

function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct.bind();
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}

function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}

function _possibleConstructorReturn(self, call) {
  if (call && (typeof call === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}

function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();

  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;

      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}

function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];

  return arr2;
}

function _createForOfIteratorHelper(o, allowArrayLike) {
  var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];

  if (!it) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it) o = it;
      var i = 0;

      var F = function () {};

      return {
        s: F,
        n: function () {
          if (i >= o.length) return {
            done: true
          };
          return {
            done: false,
            value: o[i++]
          };
        },
        e: function (e) {
          throw e;
        },
        f: F
      };
    }

    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }

  var normalCompletion = true,
      didErr = false,
      err;
  return {
    s: function () {
      it = it.call(o);
    },
    n: function () {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function (e) {
      didErr = true;
      err = e;
    },
    f: function () {
      try {
        if (!normalCompletion && it.return != null) it.return();
      } finally {
        if (didErr) throw err;
      }
    }
  };
}

var IS_BROWSER = typeof window !== 'undefined';
var HAS_NAVIGATOR = IS_BROWSER && typeof window.navigator !== 'undefined';
HAS_NAVIGATOR && /(android)/i.test(navigator.userAgent); // Bad, but needed

HAS_NAVIGATOR && /iPad|iPhone|iPod/.test(String(navigator.platform));
// Mock HTMLElement for Node

if (!IS_BROWSER && !global.HTMLElement) {
  global.HTMLElement = /*#__PURE__*/function () {
    function _class() {
      _classCallCheck(this, _class);
    }

    return _createClass(_class);
  }();
}
/**
* addStyle
* @param {String} nodeName An unique ID of the event to bind - ensurnes single instance
* @param {String} css The css to inject
*/

function addStyle(nodeName, css) {
  var key = "style-".concat(nodeName.toLowerCase());
  var min = css.replace(/\/\*[^!][^*]*\*\//g, '').replace(/\s*(^|[:;,{}]|$)\s*/g, '$1');
  document.getElementById(key) || document.head.insertAdjacentHTML('afterbegin', "<style id=\"".concat(key, "\">").concat(min, "</style>"));
}
/**
* closest
* @param {Element} element Element to traverse up from
* @param {String} selector A selector to search for matching parents or element itself
* @return {Element|null}  Element which is the closest ancestor matching selector
*/

var closest = function () {
  var proto = typeof window === 'undefined' ? {} : window.Element.prototype;
  var match = proto.matches || proto.msMatchesSelector || proto.webkitMatchesSelector;
  return proto.closest ? function (el, css) {
    return el.closest(css);
  } : function (el, css) {
    // IE jumps to shadow SVG DOM on clicking an SVG defined by <use>.
    // If so, jump back to <use> element and traverse real DOM
    if (el.correspondingUseElement) el = el.correspondingUseElement;

    for (; el; el = el.parentElement) {
      if (match.call(el, css)) return el;
    }

    return null;
  };
}();
/**
* dispatchEvent - with infinite loop prevention
* @param {Element} element The target object
* @param {String} name The event name
* @param {Object} detail Detail object (bubbles and cancelable is set to true)
* @return {Boolean} Whether the event was canceled. Returns true if either event's cancelable attribute value is false or its preventDefault() method was not invoked, and false otherwise.
*/

function dispatchEvent(element, name) {
  var detail = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
  var ignore = "prevent_recursive_dispatch_maximum_callstack".concat(name);
  var event;
  if (element[ignore]) return true; // We are already processing this event, so skip sending a new one
  else element[ignore] = true; // Add name to dispatching ignore

  if (typeof window.CustomEvent === 'function') {
    event = new window.CustomEvent(name, {
      bubbles: true,
      cancelable: true,
      detail: detail
    });
  } else {
    event = document.createEvent('CustomEvent');
    event.initCustomEvent(name, true, true, detail);
  } // IE reports incorrect event.defaultPrevented
  // but correct return value on element.dispatchEvent


  var result = element.dispatchEvent(event);
  element[ignore] = null; // Remove name from dispatching ignore

  return result; // Follow W3C standard for return value
}
/**
* getUUID
* @return {String} A generated unique ID
*/

function getUUID() {
  return Date.now().toString(36) + Math.random().toString(36).slice(2, 5);
}
/**
 * throttle
 * @param {Function} callback  The new throttled function
 * @param {Number} ms The threshold of milliseconds between each callback
 */

function throttle(callback, ms) {
  var timer;
  return function () {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    if (!timer) {
      timer = setTimeout(function () {
        callback.apply(this, args);
        timer = null;
      }, ms);
    }
  };
}
/**
* queryAll
* @param {String|NodeList|Array|Element} elements A CSS selector string, nodeList, element array, or single element
* @param {Element} context Node to look for elements within
* @return {Element[]} Array of elements
*/

function queryAll(elements) {
  var context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;

  if (elements) {
    if (elements.nodeType) return [elements];
    if (typeof elements === 'string') return [].slice.call(context.querySelectorAll(elements));
    if (elements.length) return [].slice.call(elements);
  }

  return [];
}

/**
 * @typedef {{ x: number, y: number }} scrollCoords
 */

/**
 * @typedef {object} scrollPoint
 * @property {Number} x
 * @property {Number} y
 * @property {'top' | 'bottom'} prop
 */

/**
 * @typedef {'up'| 'down' | 'left' | 'right'} scrollDirection
 */

/**
 * @typedef {Object} scrollStatus
 * @property {Number} up distance above to bounding element
 * @property {Number} right distance right to bounding element
 * @property {Number} down distance below to bounding element
 * @property {Number} left distance left to bounding element
 */

/**
 * @typedef {scrollDirection | scrollPoint | Element} scrollTarget
 */

/**
 * @typedef {Object} dragType
 * @property {String} animate Id of element to animate
 * @property {Number} diffSumX
 * @property {Number} diffSumY
 * @property {Number} diffX
 * @property {Number} diffY
 * @property {Number} pageX
 * @property {Number} pageY
 * @property {Number} scrollX
 * @property {Number} scrollY
 * @property {HTMLElement} target
 */

/**
 * @type {dragType}
 */

var DRAG = {};
var MOVE = {
  up: {
    y: -1,
    prop: 'top'
  },
  down: {
    y: 1,
    prop: 'bottom'
  },
  left: {
    x: -1
  },
  right: {
    x: 1
  }
};
var MOVE_SIGNIFICANT = 10;
var NEEDS_MOUSEDOWN = '[contenteditable="true"],input,select,textarea';

var EVENT_PASSIVE = function () {
  var has = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

  try {
    window.addEventListener('test', null, {
      get passive() {
        has = {
          passive: true
        };
      }

    });
  } catch (e) {}

  return has;
}(); // https://css-tricks.com/introduction-reduced-motion-media-query/


var requestJumps = IS_BROWSER && window.matchMedia && window.matchMedia('(prefers-reduced-motion)').matches;
var requestFrame = IS_BROWSER && (window.requestAnimationFrame || window.setTimeout);

var CoreScroll = /*#__PURE__*/function (_HTMLElement) {
  _inherits(CoreScroll, _HTMLElement);

  var _super = _createSuper(CoreScroll);

  function CoreScroll() {
    _classCallCheck(this, CoreScroll);

    return _super.apply(this, arguments);
  }

  _createClass(CoreScroll, [{
    key: "connectedCallback",
    value: function connectedCallback() {
      var _this = this;

      // Hide scrollbar in WebKit and default to display block
      addStyle(this.nodeName, "\n      ".concat(this.nodeName, "{display:block}\n      ").concat(this.nodeName, "::-webkit-scrollbar{display:none}\n    "));
      this.style.overflow = 'scroll'; // Ensure visible scrollbars

      this.style.webkitOverflowScrolling = 'touch'; // Momentum scroll on iOS
      // Calculate sizes for hiding, must be after setting overflow:scroll

      var barWidth = this.offsetWidth - this.clientWidth;
      var barHeight = this.offsetHeight - this.clientHeight; // Also ensure height does not grow higher than parent element

      this.style.marginRight = "-".concat(barWidth, "px");
      this.style.marginBottom = "-".concat(barHeight, "px");
      this.style.maxHeight = "calc(100% + ".concat(barHeight, "px)");
      this._throttledEvent = throttle(this.handleEvent.bind(this), 500);
      this.addEventListener('mousedown', this);
      this.addEventListener('wheel', this, EVENT_PASSIVE);
      this.addEventListener('scroll', this._throttledEvent, EVENT_PASSIVE);
      window.addEventListener('resize', this._throttledEvent, EVENT_PASSIVE);
      window.addEventListener('load', this); // Update state when we are sure all CSS is loaded

      document.addEventListener('click', this); // Observe children for changes and run this.handleEvent()
      // - jsx in particular relies on onScrollChange triggering to update button states

      if (!this._childListObserver && window.MutationObserver) this._childListObserver = new window.MutationObserver(onDOMchange.bind(this));
      if (this._childListObserver) this._childListObserver.observe(this, {
        childList: true,
        subtree: true
      });
      setTimeout(function () {
        return _this.handleEvent();
      }); // Initialize buttons after children is parsed
    }
  }, {
    key: "disconnectedCallback",
    value: function disconnectedCallback() {
      if (this._childListObserver) this._childListObserver.disconnect();
      this._childListObserver = this._throttledEvent = null; // Garbage collection

      this.removeEventListener('mousedown', this);
      this.removeEventListener('wheel', this, EVENT_PASSIVE);
      this.removeEventListener('scroll', this._throttledEvent, EVENT_PASSIVE);
      window.removeEventListener('resize', this._throttledEvent, EVENT_PASSIVE);
      window.removeEventListener('load', this);
      document.removeEventListener('click', this);
    }
    /**
     *
     * @param {Event} event
     */

  }, {
    key: "handleEvent",
    value: function handleEvent() {
      var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      if (!this.parentNode || event.defaultPrevented) return; // Abort if removed from DOM or event is prevented

      if (event.type === 'wheel') DRAG.animate = false; // Stop momentum animation onWheel
      else if (event.type === 'mousedown') onMousedown.call(this, event);else if (event.type === 'click') {
        var btn = this.id && closest(event.target, "[for=\"".concat(this.id, "\"],[data-for=\"").concat(this.id, "\"]"));
        if (btn && dispatchEvent(this, 'scroll.click', {
          move: btn.value
        })) this.scroll(btn.value);
      } else {
        var scrollStatus = getScrollStatus(this);
        updateButtons(this, scrollStatus);
        dispatchEvent(this, 'scroll.change');
        var cursor = scrollStatus.left || scrollStatus.right || scrollStatus.up || scrollStatus.down ? 'grab' : '';

        if (!event.type) {
          // Do not change cursor while dragging
          this.style.cursor = "-webkit-".concat(cursor);
          this.style.cursor = cursor;
        }
      }
    }
    /**
     * Scroll to Element, point or cardinal direction within core-scroll
     * @param {scrollTarget} point Element, {x, y} pixel distance from top/left or cardinal direction ['up', 'down', 'left', 'right']
     * @returns {Promise<scrollPoint>} scrollPoint
     */

  }, {
    key: "scroll",
    value: function scroll(point) {
      var _this2 = this;

      var endPoint = parsePoint(this, point);
      var x = endPoint.x,
          y = endPoint.y;
      var uuid = DRAG.animate = getUUID(); // Giving the animation an ID to workaround IE timeout issues

      var friction = this.friction;
      var moveX = requestJumps ? 1 : x - this.scrollLeft;
      var moveY = requestJumps ? 1 : y - this.scrollTop;
      return new Promise(function (resolve) {
        var move = function move() {
          if (DRAG.animate === uuid && (Math.round(moveX) || Math.round(moveY))) {
            _this2.scrollLeft = x - Math.round(moveX *= friction);
            _this2.scrollTop = y - Math.round(moveY *= friction);
            requestFrame(move);
          } else {
            resolve(endPoint);
          }
        };

        move();
      });
    }
  }, {
    key: "items",
    get: function get() {
      return queryAll(this.getAttribute('items') || this.children, this);
    } // Ensure falsy values becomes ''
    ,
    set: function set(val) {
      this.setAttribute('items', val || '');
    } // ScrollLeft can return decimals when browser is zoomed, leading to unwanted negative values

  }, {
    key: "scrollRight",
    get: function get() {
      return Math.max(0, this.scrollWidth - this.clientWidth - this.scrollLeft);
    } // Safeguard for negative due to decimals for scrollTop similar to scrollLeft above

  }, {
    key: "scrollBottom",
    get: function get() {
      return Math.max(0, this.scrollHeight - this.clientHeight - this.scrollTop);
    } // Avoid friction 1 (infinite)

  }, {
    key: "friction",
    get: function get() {
      return Math.min(0.99, this.getAttribute('friction')) || 0.8;
    },
    set: function set(val) {
      this.setAttribute('friction', val);
    }
  }]);

  return CoreScroll;
}( /*#__PURE__*/_wrapNativeSuper(HTMLElement));

function onMousedown(event) {
  if (closest(event.target, NEEDS_MOUSEDOWN)) return;
  if (event.button !== 0) return; // Only react to left clicking

  event.preventDefault(); // Prevent text selection and enable nesting

  DRAG.pageX = event.pageX;
  DRAG.pageY = event.pageY;
  DRAG.diffSumX = 0;
  DRAG.diffSumY = 0;
  DRAG.animate = DRAG.diffX = DRAG.diffY = 0; // Reset

  DRAG.scrollX = this.scrollLeft;
  DRAG.scrollY = this.scrollTop;
  DRAG.target = this;
  document.body.style.cursor = this.style.cursor = '-webkit-grabbing';
  document.body.style.cursor = this.style.cursor = 'grabbing';
  document.addEventListener('mousemove', onMousemove);
  document.addEventListener('mouseup', onMouseup);
}

function onMousemove(event) {
  DRAG.diffX = DRAG.pageX - (DRAG.pageX = event.pageX);
  DRAG.diffY = DRAG.pageY - (DRAG.pageY = event.pageY);
  DRAG.diffSumX += DRAG.diffX;
  DRAG.diffSumY += DRAG.diffY;
  DRAG.target.scrollLeft = DRAG.scrollX += DRAG.diffX;
  DRAG.target.scrollTop = DRAG.scrollY += DRAG.diffY; // Prevent links when we know there has been significant movement

  if (Math.max(Math.abs(DRAG.diffSumX), Math.abs(DRAG.diffSumY)) > MOVE_SIGNIFICANT) {
    DRAG.target.style.pointerEvents = 'none';
  }
}

function onMouseup(event) {
  var momentum = Math.abs(DRAG.diffX || DRAG.diffY) > MOVE_SIGNIFICANT ? 20 : 0;
  document.removeEventListener('mousemove', onMousemove);
  document.removeEventListener('mouseup', onMouseup);
  document.body.style.cursor = '';

  if (momentum) {
    DRAG.target.scroll({
      x: DRAG.scrollX + DRAG.diffX * momentum,
      y: DRAG.scrollY + DRAG.diffY * momentum
    });
  }

  DRAG.target.style.pointerEvents = ''; // Allow events again

  DRAG.target.style.cursor = '-webkit-grab';
  DRAG.target.style.cursor = 'grab';
  DRAG.target = null; // Prevent memory leak
}
/**
 * Takes an element, coordinates or cardinal direction and returns x/y -coordinates
 * @param {CoreScroll} self CoreScroll HTMLElement
 * @param {scrollTarget} move
 * @returns {scrollPoint}
 */


function parsePoint(self, move) {
  var scrollItems = self.items; // Move is an element within CoreScroll

  var toItem = move && move.nodeType && scrollItems.filter(function (item) {
    return item.contains(move);
  })[0];

  if (toItem) {
    // Target offset subtracting CoreScroll offset and half of offsetHeight/width to center
    return {
      x: Math.max(0, toItem.offsetLeft - self.offsetLeft - (self.offsetWidth / 2 - toItem.offsetWidth / 2)),
      y: Math.max(0, toItem.offsetTop - self.offsetTop - (self.offsetHeight / 2 - toItem.offsetHeight / 2))
    };
  } else if (move && move.nodeType && !toItem) {
    console.warn(self, "cannot find child element ".concat(move, " as a valid target for scrolling"));
  }

  var point = _typeof(move) === 'object' ? move : {
    move: move
  };
  if (typeof point.x !== 'number') point.x = self.scrollLeft;
  if (typeof point.y !== 'number') point.y = self.scrollTop;

  if (point.move = MOVE[point.move]) {
    var axis = point.move.x ? 'x' : 'y';
    var start = point.move.x ? 'left' : 'top';
    var bounds = self.getBoundingClientRect();
    var scroll = bounds[start] - self[point.move.x ? 'scrollLeft' : 'scrollTop'];
    var edge = bounds[start] + bounds[point.move.x ? 'width' : 'height'] * point.move[axis];
    scrollItems.every(function (el) {
      // Use .every as this loop stops on return false
      var rect = el.getBoundingClientRect();
      var marg = el.ownerDocument.defaultView.getComputedStyle(el)["margin-".concat(start)];
      point[axis] = rect[start] - parseInt(marg, 10) - scroll; // Update point to child axis coordinate

      return rect[point.move.prop || move] < edge;
    });
  }

  return {
    x: Math.max(0, Math.min(point.x, self.scrollWidth - self.clientWidth)),
    y: Math.max(0, Math.min(point.y, self.scrollHeight - self.clientHeight))
  };
}
/**
 * scroll.DOMChange
 *
 * fired when MutationObserver in CoreScroll detects a change in child nodes
 *
 * @event scroll.DOMChange
 * @type {object}
 * @param {NodeList} addedNodes
 * @param {NodeList} removedNodes
 */

/**
 * Handle DOM changes in childlist observed with MutationObserver in CoreScroll
 *
 * @this {CoreScroll} CoreScroll HTMLElement
 * @param {MutationRecord[]} mutationList
 * @fires scroll.DOMChange when a MutationRecord has type childList
 */


function onDOMchange(mutationList) {
  if (!this.parentNode) return; // Abort if removed from DOM

  var _iterator = _createForOfIteratorHelper(mutationList),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var mutation = _step.value;

      /* One or more children have been added to and/or removed from the tree. */
      if (mutation.type === 'childList') {
        var scrollStatus = getScrollStatus(this);
        updateButtons(this, scrollStatus);
        dispatchEvent(this, 'scroll.change');
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
/**
 * getScrollStatus
 * We floor all values to handle potential decimal leftovers if browser is zoomed in or out
 * @param {CoreScroll} self CoreScroll HTMLElement
 * @returns {scrollStatus} Object with values for distance to bounding element in cardinal directions
 */


function getScrollStatus(self) {
  return {
    up: Math.floor(self.scrollTop),
    right: Math.floor(self.scrollRight),
    down: Math.floor(self.scrollBottom),
    left: Math.floor(self.scrollLeft)
  };
}
/**
 * Updates disabled attribute on all connected buttons with value set as a scrollDirection
 * @param {CoreScroll} self CoreScroll HTMLElement
 * @param {scrollStatus} scrollStatus
 */


function updateButtons(self, scrollStatus) {
  queryAll(self.id && "[for=\"".concat(self.id, "\"],[data-for=\"").concat(self.id, "\"]")).forEach(function (el) {
    return el.disabled = !scrollStatus[el.value];
  });
}

module.exports = CoreScroll;
